import { useEffect, useState } from 'react';
import '/src/App.css';
import axios from 'axios';

interface WeatherData {
    date: string;
    morning?: number;
    day?: number;
    evening?: number;
    night?: number;
    icon?: string;
    dayOfWeek?: string; // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª–µ –¥–ª—è –¥–Ω—è –Ω–µ–¥–µ–ª–∏
}

interface WeatherDailyProps {
    city: string;
    days: number;
    dayNames?: string[]; // –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –ø—Ä–æ–ø—Å –¥–ª—è –∫–∞—Å—Ç–æ–º–Ω—ã—Ö –Ω–∞–∑–≤–∞–Ω–∏–π –¥–Ω–µ–π
}

const API_KEY = 'a3020bcd380e283571def6dc5e97aea1';

const DEFAULT_DAY_NAMES = ['–ü–Ω', '–í—Ç', '–°—Ä', '–ß—Ç', '–ü—Ç', '–°–±', '–í—Å'];

const getWeatherIcon = (iconCode: string | undefined) => {
    switch (iconCode) {
        case '01d':
        case '01n':
            return '‚òÄÔ∏è';
        case '02d':
        case '02n':
            return '‚õÖ';
        case '03d':
        case '03n':
        case '04d':
        case '04n':
            return '‚òÅÔ∏è';
        case '09d':
        case '09n':
            return 'üåßÔ∏è';
        case '10d':
        case '10n':
            return 'üå¶Ô∏è';
        case '11d':
        case '11n':
            return '‚õàÔ∏è';
        case '13d':
        case '13n':
            return '‚ùÑÔ∏è';
        case '50d':
        case '50n':
            return 'üå´Ô∏è';
        default:
            return 'üåà';
    }
};

const WeatherDaily: React.FC<WeatherDailyProps> = ({ 
    city, 
    days, 
    dayNames = DEFAULT_DAY_NAMES 
}) => {
    const [forecast, setForecast] = useState<WeatherData[]>([]);
    const [error, setError] = useState<string | null>(null);
    const [loading, setLoading] = useState(false);

    useEffect(() => {
        const fetchWeather = async () => {
            if (!city) return;
            setLoading(true);
            setError(null);
            try {
                const response = await axios.get(
                    `http://api.openweathermap.org/data/2.5/forecast?q=${city}&appid=${API_KEY}&units=metric&lang=ru`
                );

                const forecastByDay: { [key: string]: WeatherData } = {};
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                response.data.list.forEach((entry: any) => {
                    const dt = new Date(entry.dt * 1000);
                    const dateStr = dt.toLocaleDateString('ru-RU', {
                        day: '2-digit',
                        month: '2-digit',
                        year: 'numeric',
                    });

                    if (!forecastByDay[dateStr]) {
                        // –í—ã—á–∏—Å–ª—è–µ–º –¥–µ–Ω—å –Ω–µ–¥–µ–ª–∏ (0 - –≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ, 1 - –ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫ –∏ —Ç.–¥.)
                        const dayIdx = dt.getDay();
                        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –Ω–∞—à —Ñ–æ—Ä–º–∞—Ç (1 - –ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫, 7 - –≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ)
                        const normalizedDayIdx = dayIdx === 0 ? 6 : dayIdx - 1;
                        
                        forecastByDay[dateStr] = { 
                            date: dateStr,
                            icon: entry.weather[0].icon,
                            dayOfWeek: dayNames[normalizedDayIdx] // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è
                        };
                    }

                    const hour = dt.getHours();
                    const temp = Math.round(entry.main.temp);

                    if (6 <= hour && hour < 12) {
                        forecastByDay[dateStr].morning = temp;
                    } else if (12 <= hour && hour < 18) {
                        forecastByDay[dateStr].day = temp;
                    } else if (18 <= hour && hour < 24) {
                        forecastByDay[dateStr].evening = temp;
                    } else {
                        forecastByDay[dateStr].night = temp;
                    }
                });

                const forecastArray = Object.values(forecastByDay)
                    .slice(0, days)
                    .sort((a, b) => {
                        // –°–æ—Ä—Ç–∏—Ä—É–µ–º –¥–Ω–∏ –ø–æ –ø–æ—Ä—è–¥–∫—É
                        const dateA = new Date(a.date.split('.').reverse().join('-'));
                        const dateB = new Date(b.date.split('.').reverse().join('-'));
                        return dateA.getTime() - dateB.getTime();
                    });

                setForecast(forecastArray);
            } catch (err) {
                setError('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–∞–Ω–Ω—ã—Ö. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≥–æ—Ä–æ–¥–∞.');
            } finally {
                setLoading(false);
            }
        };

        fetchWeather();
    }, [city, days, dayNames]);

    if (loading) return <div>–ó–∞–≥—Ä—É–∑–∫–∞...</div>;
    if (error) return <div>{error}</div>;

    return (
        <div className="WeatherDaily-Container">
            {forecast.map((day) => (
                <div className="WeatherDaily-Card" key={day.date}>
                    <div className="day">
                        <span className="day-title">{day.dayOfWeek}</span>
                        <hr className="day-hr" />
                        <div className="day-icon">{getWeatherIcon(day.icon)}</div>
                        <hr className="day-hr" />
                        <div className="temps">
                            <span>–£—Ç—Ä–æ {day.morning ?? '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}¬∞</span>
                            <span>–î–µ–Ω—å {day.day ?? '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}¬∞</span>
                            <span>–í–µ—á–µ—Ä {day.evening ?? '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}¬∞</span>
                            <span>–ù–æ—á—å {day.night ?? '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}¬∞</span>
                        </div>
                    </div>
                </div>
            ))}
        </div>
    );
};

export default WeatherDaily;